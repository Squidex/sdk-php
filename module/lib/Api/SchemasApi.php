<?php
/**
 * SchemasApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Squidex API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SchemasApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SchemasApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'schemaFieldsDeleteField' => [
            'application/json',
        ],
        'schemaFieldsDeleteNestedField' => [
            'application/json',
        ],
        'schemaFieldsDisableField' => [
            'application/json',
        ],
        'schemaFieldsDisableNestedField' => [
            'application/json',
        ],
        'schemaFieldsEnableField' => [
            'application/json',
        ],
        'schemaFieldsEnableNestedField' => [
            'application/json',
        ],
        'schemaFieldsHideField' => [
            'application/json',
        ],
        'schemaFieldsHideNestedField' => [
            'application/json',
        ],
        'schemaFieldsLockField' => [
            'application/json',
        ],
        'schemaFieldsLockNestedField' => [
            'application/json',
        ],
        'schemaFieldsPostField' => [
            'application/json',
        ],
        'schemaFieldsPostNestedField' => [
            'application/json',
        ],
        'schemaFieldsPutField' => [
            'application/json',
        ],
        'schemaFieldsPutNestedField' => [
            'application/json',
        ],
        'schemaFieldsPutNestedFieldOrdering' => [
            'application/json',
        ],
        'schemaFieldsPutSchemaFieldOrdering' => [
            'application/json',
        ],
        'schemaFieldsPutSchemaUIFields' => [
            'application/json',
        ],
        'schemaFieldsShowField' => [
            'application/json',
        ],
        'schemaFieldsShowNestedField' => [
            'application/json',
        ],
        'schemasDeleteSchema' => [
            'application/json',
        ],
        'schemasGetSchema' => [
            'application/json',
        ],
        'schemasGetSchemas' => [
            'application/json',
        ],
        'schemasPostSchema' => [
            'application/json',
        ],
        'schemasPublishSchema' => [
            'application/json',
        ],
        'schemasPutCategory' => [
            'application/json',
        ],
        'schemasPutPreviewUrls' => [
            'application/json',
        ],
        'schemasPutRules' => [
            'application/json',
        ],
        'schemasPutSchema' => [
            'application/json',
        ],
        'schemasPutSchemaSync' => [
            'application/json',
        ],
        'schemasPutScripts' => [
            'application/json',
        ],
        'schemasUnpublishSchema' => [
            'application/json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation schemaFieldsDeleteField
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsDeleteField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDeleteField'][0])
    {
        list($response) = $this->schemaFieldsDeleteFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsDeleteFieldWithHttpInfo
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsDeleteFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDeleteField'][0])
    {
        $request = $this->schemaFieldsDeleteFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsDeleteFieldAsync
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDeleteFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDeleteField'][0])
    {
        return $this->schemaFieldsDeleteFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsDeleteFieldAsyncWithHttpInfo
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDeleteFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDeleteField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsDeleteFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsDeleteField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsDeleteFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDeleteField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsDeleteField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsDeleteField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsDeleteField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsDeleteNestedField
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsDeleteNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDeleteNestedField'][0])
    {
        list($response) = $this->schemaFieldsDeleteNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsDeleteNestedFieldWithHttpInfo
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsDeleteNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDeleteNestedField'][0])
    {
        $request = $this->schemaFieldsDeleteNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsDeleteNestedFieldAsync
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDeleteNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDeleteNestedField'][0])
    {
        return $this->schemaFieldsDeleteNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsDeleteNestedFieldAsyncWithHttpInfo
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDeleteNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDeleteNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsDeleteNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsDeleteNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDeleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsDeleteNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDeleteNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsDeleteNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsDeleteNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsDeleteNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsDeleteNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsDisableField
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsDisableField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDisableField'][0])
    {
        list($response) = $this->schemaFieldsDisableFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsDisableFieldWithHttpInfo
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsDisableFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDisableField'][0])
    {
        $request = $this->schemaFieldsDisableFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsDisableFieldAsync
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDisableFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDisableField'][0])
    {
        return $this->schemaFieldsDisableFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsDisableFieldAsyncWithHttpInfo
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDisableFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDisableField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsDisableFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsDisableField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsDisableFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsDisableField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsDisableField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsDisableField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsDisableField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsDisableNestedField
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsDisableNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDisableNestedField'][0])
    {
        list($response) = $this->schemaFieldsDisableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsDisableNestedFieldWithHttpInfo
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsDisableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDisableNestedField'][0])
    {
        $request = $this->schemaFieldsDisableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsDisableNestedFieldAsync
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDisableNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDisableNestedField'][0])
    {
        return $this->schemaFieldsDisableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsDisableNestedFieldAsyncWithHttpInfo
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsDisableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDisableNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsDisableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsDisableNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsDisableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsDisableNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsDisableNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsDisableNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsDisableNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsDisableNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsDisableNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsEnableField
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsEnableField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsEnableField'][0])
    {
        list($response) = $this->schemaFieldsEnableFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsEnableFieldWithHttpInfo
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsEnableFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsEnableField'][0])
    {
        $request = $this->schemaFieldsEnableFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsEnableFieldAsync
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsEnableFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsEnableField'][0])
    {
        return $this->schemaFieldsEnableFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsEnableFieldAsyncWithHttpInfo
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsEnableFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsEnableField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsEnableFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsEnableField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsEnableFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsEnableField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsEnableField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsEnableField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsEnableField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsEnableNestedField
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsEnableNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsEnableNestedField'][0])
    {
        list($response) = $this->schemaFieldsEnableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsEnableNestedFieldWithHttpInfo
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsEnableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsEnableNestedField'][0])
    {
        $request = $this->schemaFieldsEnableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsEnableNestedFieldAsync
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsEnableNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsEnableNestedField'][0])
    {
        return $this->schemaFieldsEnableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsEnableNestedFieldAsyncWithHttpInfo
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsEnableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsEnableNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsEnableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsEnableNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsEnableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsEnableNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsEnableNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsEnableNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsEnableNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsEnableNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsEnableNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsHideField
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsHideField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsHideField'][0])
    {
        list($response) = $this->schemaFieldsHideFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsHideFieldWithHttpInfo
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsHideFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsHideField'][0])
    {
        $request = $this->schemaFieldsHideFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsHideFieldAsync
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsHideFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsHideField'][0])
    {
        return $this->schemaFieldsHideFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsHideFieldAsyncWithHttpInfo
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsHideFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsHideField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsHideFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsHideField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsHideFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsHideField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsHideField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsHideField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsHideField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsHideNestedField
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsHideNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsHideNestedField'][0])
    {
        list($response) = $this->schemaFieldsHideNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsHideNestedFieldWithHttpInfo
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsHideNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsHideNestedField'][0])
    {
        $request = $this->schemaFieldsHideNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsHideNestedFieldAsync
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsHideNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsHideNestedField'][0])
    {
        return $this->schemaFieldsHideNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsHideNestedFieldAsyncWithHttpInfo
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsHideNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsHideNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsHideNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsHideNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsHideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsHideNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsHideNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsHideNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsHideNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsHideNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsHideNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsLockField
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsLockField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsLockField'][0])
    {
        list($response) = $this->schemaFieldsLockFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsLockFieldWithHttpInfo
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsLockFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsLockField'][0])
    {
        $request = $this->schemaFieldsLockFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsLockFieldAsync
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsLockFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsLockField'][0])
    {
        return $this->schemaFieldsLockFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsLockFieldAsyncWithHttpInfo
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsLockFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsLockField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsLockFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsLockField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsLockFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsLockField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsLockField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsLockField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsLockField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsLockNestedField
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsLockNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsLockNestedField'][0])
    {
        list($response) = $this->schemaFieldsLockNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsLockNestedFieldWithHttpInfo
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsLockNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsLockNestedField'][0])
    {
        $request = $this->schemaFieldsLockNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsLockNestedFieldAsync
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsLockNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsLockNestedField'][0])
    {
        return $this->schemaFieldsLockNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsLockNestedFieldAsyncWithHttpInfo
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsLockNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsLockNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsLockNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsLockNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsLockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsLockNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsLockNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsLockNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsLockNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsLockNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsLockNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPostField
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPostField($app, $schema, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostField'][0])
    {
        list($response) = $this->schemaFieldsPostFieldWithHttpInfo($app, $schema, $add_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPostFieldWithHttpInfo
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPostFieldWithHttpInfo($app, $schema, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostField'][0])
    {
        $request = $this->schemaFieldsPostFieldRequest($app, $schema, $add_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPostFieldAsync
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPostFieldAsync($app, $schema, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostField'][0])
    {
        return $this->schemaFieldsPostFieldAsyncWithHttpInfo($app, $schema, $add_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPostFieldAsyncWithHttpInfo
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPostFieldAsyncWithHttpInfo($app, $schema, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPostFieldRequest($app, $schema, $add_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPostField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPostFieldRequest($app, $schema, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPostField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPostField'
            );
        }

        // verify the required parameter 'add_field_dto' is set
        if ($add_field_dto === null || (is_array($add_field_dto) && count($add_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_field_dto when calling schemaFieldsPostField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_field_dto));
            } else {
                $httpBody = $add_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPostNestedField
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPostNestedField($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostNestedField'][0])
    {
        list($response) = $this->schemaFieldsPostNestedFieldWithHttpInfo($app, $schema, $parent_id, $add_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPostNestedFieldWithHttpInfo
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPostNestedFieldWithHttpInfo($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostNestedField'][0])
    {
        $request = $this->schemaFieldsPostNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPostNestedFieldAsync
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPostNestedFieldAsync($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostNestedField'][0])
    {
        return $this->schemaFieldsPostNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $add_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPostNestedFieldAsyncWithHttpInfo
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPostNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPostNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPostNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPostNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPostNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['schemaFieldsPostNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPostNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPostNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsPostNestedField'
            );
        }

        // verify the required parameter 'add_field_dto' is set
        if ($add_field_dto === null || (is_array($add_field_dto) && count($add_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_field_dto when calling schemaFieldsPostNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_field_dto));
            } else {
                $httpBody = $add_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPutField
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPutField($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutField'][0])
    {
        list($response) = $this->schemaFieldsPutFieldWithHttpInfo($app, $schema, $id, $update_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPutFieldWithHttpInfo
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPutFieldWithHttpInfo($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutField'][0])
    {
        $request = $this->schemaFieldsPutFieldRequest($app, $schema, $id, $update_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPutFieldAsync
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutFieldAsync($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutField'][0])
    {
        return $this->schemaFieldsPutFieldAsyncWithHttpInfo($app, $schema, $id, $update_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPutFieldAsyncWithHttpInfo
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutFieldAsyncWithHttpInfo($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPutFieldRequest($app, $schema, $id, $update_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPutField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPutFieldRequest($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPutField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPutField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsPutField'
            );
        }

        // verify the required parameter 'update_field_dto' is set
        if ($update_field_dto === null || (is_array($update_field_dto) && count($update_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_field_dto when calling schemaFieldsPutField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_field_dto));
            } else {
                $httpBody = $update_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPutNestedField
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPutNestedField($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedField'][0])
    {
        list($response) = $this->schemaFieldsPutNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPutNestedFieldWithHttpInfo
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPutNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedField'][0])
    {
        $request = $this->schemaFieldsPutNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPutNestedFieldAsync
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutNestedFieldAsync($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedField'][0])
    {
        return $this->schemaFieldsPutNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPutNestedFieldAsyncWithHttpInfo
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPutNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPutNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \OpenAPI\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPutNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPutNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPutNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsPutNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsPutNestedField'
            );
        }

        // verify the required parameter 'update_field_dto' is set
        if ($update_field_dto === null || (is_array($update_field_dto) && count($update_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_field_dto when calling schemaFieldsPutNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_field_dto));
            } else {
                $httpBody = $update_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPutNestedFieldOrdering
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPutNestedFieldOrdering($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedFieldOrdering'][0])
    {
        list($response) = $this->schemaFieldsPutNestedFieldOrderingWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPutNestedFieldOrderingWithHttpInfo
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPutNestedFieldOrderingWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedFieldOrdering'][0])
    {
        $request = $this->schemaFieldsPutNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPutNestedFieldOrderingAsync
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutNestedFieldOrderingAsync($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedFieldOrdering'][0])
    {
        return $this->schemaFieldsPutNestedFieldOrderingAsyncWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPutNestedFieldOrderingAsyncWithHttpInfo
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutNestedFieldOrderingAsyncWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedFieldOrdering'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPutNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPutNestedFieldOrdering'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPutNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutNestedFieldOrdering'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPutNestedFieldOrdering'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPutNestedFieldOrdering'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsPutNestedFieldOrdering'
            );
        }

        // verify the required parameter 'reorder_fields_dto' is set
        if ($reorder_fields_dto === null || (is_array($reorder_fields_dto) && count($reorder_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reorder_fields_dto when calling schemaFieldsPutNestedFieldOrdering'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/ordering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reorder_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reorder_fields_dto));
            } else {
                $httpBody = $reorder_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPutSchemaFieldOrdering
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPutSchemaFieldOrdering($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaFieldOrdering'][0])
    {
        list($response) = $this->schemaFieldsPutSchemaFieldOrderingWithHttpInfo($app, $schema, $reorder_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPutSchemaFieldOrderingWithHttpInfo
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPutSchemaFieldOrderingWithHttpInfo($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaFieldOrdering'][0])
    {
        $request = $this->schemaFieldsPutSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPutSchemaFieldOrderingAsync
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutSchemaFieldOrderingAsync($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaFieldOrdering'][0])
    {
        return $this->schemaFieldsPutSchemaFieldOrderingAsyncWithHttpInfo($app, $schema, $reorder_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPutSchemaFieldOrderingAsyncWithHttpInfo
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutSchemaFieldOrderingAsyncWithHttpInfo($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaFieldOrdering'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPutSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPutSchemaFieldOrdering'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPutSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaFieldOrdering'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPutSchemaFieldOrdering'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPutSchemaFieldOrdering'
            );
        }

        // verify the required parameter 'reorder_fields_dto' is set
        if ($reorder_fields_dto === null || (is_array($reorder_fields_dto) && count($reorder_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reorder_fields_dto when calling schemaFieldsPutSchemaFieldOrdering'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/ordering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reorder_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reorder_fields_dto));
            } else {
                $httpBody = $reorder_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsPutSchemaUIFields
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsPutSchemaUIFields($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaUIFields'][0])
    {
        list($response) = $this->schemaFieldsPutSchemaUIFieldsWithHttpInfo($app, $schema, $configure_ui_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsPutSchemaUIFieldsWithHttpInfo
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsPutSchemaUIFieldsWithHttpInfo($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaUIFields'][0])
    {
        $request = $this->schemaFieldsPutSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsPutSchemaUIFieldsAsync
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutSchemaUIFieldsAsync($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaUIFields'][0])
    {
        return $this->schemaFieldsPutSchemaUIFieldsAsyncWithHttpInfo($app, $schema, $configure_ui_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsPutSchemaUIFieldsAsyncWithHttpInfo
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsPutSchemaUIFieldsAsyncWithHttpInfo($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaUIFields'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsPutSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsPutSchemaUIFields'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsPutSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsPutSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['schemaFieldsPutSchemaUIFields'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsPutSchemaUIFields'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsPutSchemaUIFields'
            );
        }

        // verify the required parameter 'configure_ui_fields_dto' is set
        if ($configure_ui_fields_dto === null || (is_array($configure_ui_fields_dto) && count($configure_ui_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configure_ui_fields_dto when calling schemaFieldsPutSchemaUIFields'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/ui';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($configure_ui_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($configure_ui_fields_dto));
            } else {
                $httpBody = $configure_ui_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsShowField
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsShowField($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsShowField'][0])
    {
        list($response) = $this->schemaFieldsShowFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsShowFieldWithHttpInfo
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsShowFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsShowField'][0])
    {
        $request = $this->schemaFieldsShowFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsShowFieldAsync
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsShowFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsShowField'][0])
    {
        return $this->schemaFieldsShowFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsShowFieldAsyncWithHttpInfo
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsShowFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsShowField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsShowFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsShowField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsShowFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['schemaFieldsShowField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsShowField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsShowField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsShowField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/show';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemaFieldsShowNestedField
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemaFieldsShowNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsShowNestedField'][0])
    {
        list($response) = $this->schemaFieldsShowNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation schemaFieldsShowNestedFieldWithHttpInfo
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowNestedField'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemaFieldsShowNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsShowNestedField'][0])
    {
        $request = $this->schemaFieldsShowNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemaFieldsShowNestedFieldAsync
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsShowNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsShowNestedField'][0])
    {
        return $this->schemaFieldsShowNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemaFieldsShowNestedFieldAsyncWithHttpInfo
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemaFieldsShowNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsShowNestedField'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemaFieldsShowNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemaFieldsShowNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemaFieldsShowNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemaFieldsShowNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['schemaFieldsShowNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemaFieldsShowNestedField'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemaFieldsShowNestedField'
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling schemaFieldsShowNestedField'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling schemaFieldsShowNestedField'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/show';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasDeleteSchema
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasDeleteSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function schemasDeleteSchema($app, $schema, string $contentType = self::contentTypes['schemasDeleteSchema'][0])
    {
        $this->schemasDeleteSchemaWithHttpInfo($app, $schema, $contentType);
    }

    /**
     * Operation schemasDeleteSchemaWithHttpInfo
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasDeleteSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasDeleteSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasDeleteSchema'][0])
    {
        $request = $this->schemasDeleteSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasDeleteSchemaAsync
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasDeleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasDeleteSchemaAsync($app, $schema, string $contentType = self::contentTypes['schemasDeleteSchema'][0])
    {
        return $this->schemasDeleteSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasDeleteSchemaAsyncWithHttpInfo
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasDeleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasDeleteSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasDeleteSchema'][0])
    {
        $returnType = '';
        $request = $this->schemasDeleteSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasDeleteSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasDeleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasDeleteSchemaRequest($app, $schema, string $contentType = self::contentTypes['schemasDeleteSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasDeleteSchema'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasDeleteSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasGetSchema
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasGetSchema($app, $schema, string $contentType = self::contentTypes['schemasGetSchema'][0])
    {
        list($response) = $this->schemasGetSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation schemasGetSchemaWithHttpInfo
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasGetSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasGetSchema'][0])
    {
        $request = $this->schemasGetSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasGetSchemaAsync
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasGetSchemaAsync($app, $schema, string $contentType = self::contentTypes['schemasGetSchema'][0])
    {
        return $this->schemasGetSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasGetSchemaAsyncWithHttpInfo
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasGetSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasGetSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasGetSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasGetSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasGetSchemaRequest($app, $schema, string $contentType = self::contentTypes['schemasGetSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasGetSchema'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasGetSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasGetSchemas
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchemas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemasDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasGetSchemas($app, string $contentType = self::contentTypes['schemasGetSchemas'][0])
    {
        list($response) = $this->schemasGetSchemasWithHttpInfo($app, $contentType);
        return $response;
    }

    /**
     * Operation schemasGetSchemasWithHttpInfo
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchemas'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemasDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasGetSchemasWithHttpInfo($app, string $contentType = self::contentTypes['schemasGetSchemas'][0])
    {
        $request = $this->schemasGetSchemasRequest($app, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemasDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemasDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemasDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemasDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemasDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasGetSchemasAsync
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasGetSchemasAsync($app, string $contentType = self::contentTypes['schemasGetSchemas'][0])
    {
        return $this->schemasGetSchemasAsyncWithHttpInfo($app, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasGetSchemasAsyncWithHttpInfo
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasGetSchemasAsyncWithHttpInfo($app, string $contentType = self::contentTypes['schemasGetSchemas'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemasDto';
        $request = $this->schemasGetSchemasRequest($app, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasGetSchemas'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasGetSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasGetSchemasRequest($app, string $contentType = self::contentTypes['schemasGetSchemas'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasGetSchemas'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPostSchema
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \OpenAPI\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPostSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPostSchema($app, $create_schema_dto, string $contentType = self::contentTypes['schemasPostSchema'][0])
    {
        list($response) = $this->schemasPostSchemaWithHttpInfo($app, $create_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPostSchemaWithHttpInfo
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \OpenAPI\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPostSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPostSchemaWithHttpInfo($app, $create_schema_dto, string $contentType = self::contentTypes['schemasPostSchema'][0])
    {
        $request = $this->schemasPostSchemaRequest($app, $create_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPostSchemaAsync
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \OpenAPI\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPostSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPostSchemaAsync($app, $create_schema_dto, string $contentType = self::contentTypes['schemasPostSchema'][0])
    {
        return $this->schemasPostSchemaAsyncWithHttpInfo($app, $create_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPostSchemaAsyncWithHttpInfo
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \OpenAPI\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPostSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPostSchemaAsyncWithHttpInfo($app, $create_schema_dto, string $contentType = self::contentTypes['schemasPostSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPostSchemaRequest($app, $create_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPostSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  \OpenAPI\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPostSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPostSchemaRequest($app, $create_schema_dto, string $contentType = self::contentTypes['schemasPostSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPostSchema'
            );
        }

        // verify the required parameter 'create_schema_dto' is set
        if ($create_schema_dto === null || (is_array($create_schema_dto) && count($create_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_schema_dto when calling schemasPostSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_schema_dto));
            } else {
                $httpBody = $create_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPublishSchema
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPublishSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPublishSchema($app, $schema, string $contentType = self::contentTypes['schemasPublishSchema'][0])
    {
        list($response) = $this->schemasPublishSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation schemasPublishSchemaWithHttpInfo
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPublishSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPublishSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasPublishSchema'][0])
    {
        $request = $this->schemasPublishSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPublishSchemaAsync
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPublishSchemaAsync($app, $schema, string $contentType = self::contentTypes['schemasPublishSchema'][0])
    {
        return $this->schemasPublishSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPublishSchemaAsyncWithHttpInfo
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPublishSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasPublishSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPublishSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPublishSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPublishSchemaRequest($app, $schema, string $contentType = self::contentTypes['schemasPublishSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPublishSchema'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPublishSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutCategory
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutCategory($app, $schema, $change_category_dto, string $contentType = self::contentTypes['schemasPutCategory'][0])
    {
        list($response) = $this->schemasPutCategoryWithHttpInfo($app, $schema, $change_category_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutCategoryWithHttpInfo
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutCategory'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutCategoryWithHttpInfo($app, $schema, $change_category_dto, string $contentType = self::contentTypes['schemasPutCategory'][0])
    {
        $request = $this->schemasPutCategoryRequest($app, $schema, $change_category_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutCategoryAsync
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutCategoryAsync($app, $schema, $change_category_dto, string $contentType = self::contentTypes['schemasPutCategory'][0])
    {
        return $this->schemasPutCategoryAsyncWithHttpInfo($app, $schema, $change_category_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutCategoryAsyncWithHttpInfo
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutCategoryAsyncWithHttpInfo($app, $schema, $change_category_dto, string $contentType = self::contentTypes['schemasPutCategory'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutCategoryRequest($app, $schema, $change_category_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutCategory'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutCategoryRequest($app, $schema, $change_category_dto, string $contentType = self::contentTypes['schemasPutCategory'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutCategory'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutCategory'
            );
        }

        // verify the required parameter 'change_category_dto' is set
        if ($change_category_dto === null || (is_array($change_category_dto) && count($change_category_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_category_dto when calling schemasPutCategory'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/category';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($change_category_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($change_category_dto));
            } else {
                $httpBody = $change_category_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutPreviewUrls
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutPreviewUrls'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutPreviewUrls($app, $schema, $request_body, string $contentType = self::contentTypes['schemasPutPreviewUrls'][0])
    {
        list($response) = $this->schemasPutPreviewUrlsWithHttpInfo($app, $schema, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutPreviewUrlsWithHttpInfo
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutPreviewUrls'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutPreviewUrlsWithHttpInfo($app, $schema, $request_body, string $contentType = self::contentTypes['schemasPutPreviewUrls'][0])
    {
        $request = $this->schemasPutPreviewUrlsRequest($app, $schema, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutPreviewUrlsAsync
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutPreviewUrlsAsync($app, $schema, $request_body, string $contentType = self::contentTypes['schemasPutPreviewUrls'][0])
    {
        return $this->schemasPutPreviewUrlsAsyncWithHttpInfo($app, $schema, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutPreviewUrlsAsyncWithHttpInfo
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutPreviewUrlsAsyncWithHttpInfo($app, $schema, $request_body, string $contentType = self::contentTypes['schemasPutPreviewUrls'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutPreviewUrlsRequest($app, $schema, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutPreviewUrls'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutPreviewUrlsRequest($app, $schema, $request_body, string $contentType = self::contentTypes['schemasPutPreviewUrls'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutPreviewUrls'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutPreviewUrls'
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling schemasPutPreviewUrls'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/preview-urls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutRules
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutRules($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['schemasPutRules'][0])
    {
        list($response) = $this->schemasPutRulesWithHttpInfo($app, $schema, $configure_field_rules_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutRulesWithHttpInfo
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutRules'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutRulesWithHttpInfo($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['schemasPutRules'][0])
    {
        $request = $this->schemasPutRulesRequest($app, $schema, $configure_field_rules_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutRulesAsync
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutRulesAsync($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['schemasPutRules'][0])
    {
        return $this->schemasPutRulesAsyncWithHttpInfo($app, $schema, $configure_field_rules_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutRulesAsyncWithHttpInfo
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutRulesAsyncWithHttpInfo($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['schemasPutRules'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutRulesRequest($app, $schema, $configure_field_rules_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutRules'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutRulesRequest($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['schemasPutRules'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutRules'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutRules'
            );
        }

        // verify the required parameter 'configure_field_rules_dto' is set
        if ($configure_field_rules_dto === null || (is_array($configure_field_rules_dto) && count($configure_field_rules_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configure_field_rules_dto when calling schemasPutRules'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($configure_field_rules_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($configure_field_rules_dto));
            } else {
                $httpBody = $configure_field_rules_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutSchema
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutSchema($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['schemasPutSchema'][0])
    {
        list($response) = $this->schemasPutSchemaWithHttpInfo($app, $schema, $update_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutSchemaWithHttpInfo
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutSchemaWithHttpInfo($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['schemasPutSchema'][0])
    {
        $request = $this->schemasPutSchemaRequest($app, $schema, $update_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutSchemaAsync
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutSchemaAsync($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['schemasPutSchema'][0])
    {
        return $this->schemasPutSchemaAsyncWithHttpInfo($app, $schema, $update_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutSchemaAsyncWithHttpInfo
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutSchemaAsyncWithHttpInfo($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['schemasPutSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutSchemaRequest($app, $schema, $update_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutSchemaRequest($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['schemasPutSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutSchema'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutSchema'
            );
        }

        // verify the required parameter 'update_schema_dto' is set
        if ($update_schema_dto === null || (is_array($update_schema_dto) && count($update_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_schema_dto when calling schemasPutSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_schema_dto));
            } else {
                $httpBody = $update_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutSchemaSync
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchemaSync'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutSchemaSync($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['schemasPutSchemaSync'][0])
    {
        list($response) = $this->schemasPutSchemaSyncWithHttpInfo($app, $schema, $synchronize_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutSchemaSyncWithHttpInfo
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchemaSync'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutSchemaSyncWithHttpInfo($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['schemasPutSchemaSync'][0])
    {
        $request = $this->schemasPutSchemaSyncRequest($app, $schema, $synchronize_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutSchemaSyncAsync
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutSchemaSyncAsync($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['schemasPutSchemaSync'][0])
    {
        return $this->schemasPutSchemaSyncAsyncWithHttpInfo($app, $schema, $synchronize_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutSchemaSyncAsyncWithHttpInfo
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutSchemaSyncAsyncWithHttpInfo($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['schemasPutSchemaSync'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutSchemaSyncRequest($app, $schema, $synchronize_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutSchemaSync'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutSchemaSyncRequest($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['schemasPutSchemaSync'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutSchemaSync'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutSchemaSync'
            );
        }

        // verify the required parameter 'synchronize_schema_dto' is set
        if ($synchronize_schema_dto === null || (is_array($synchronize_schema_dto) && count($synchronize_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $synchronize_schema_dto when calling schemasPutSchemaSync'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($synchronize_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($synchronize_schema_dto));
            } else {
                $httpBody = $synchronize_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasPutScripts
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutScripts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasPutScripts($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['schemasPutScripts'][0])
    {
        list($response) = $this->schemasPutScriptsWithHttpInfo($app, $schema, $schema_scripts_dto, $contentType);
        return $response;
    }

    /**
     * Operation schemasPutScriptsWithHttpInfo
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutScripts'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasPutScriptsWithHttpInfo($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['schemasPutScripts'][0])
    {
        $request = $this->schemasPutScriptsRequest($app, $schema, $schema_scripts_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasPutScriptsAsync
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutScriptsAsync($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['schemasPutScripts'][0])
    {
        return $this->schemasPutScriptsAsyncWithHttpInfo($app, $schema, $schema_scripts_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasPutScriptsAsyncWithHttpInfo
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasPutScriptsAsyncWithHttpInfo($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['schemasPutScripts'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasPutScriptsRequest($app, $schema, $schema_scripts_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasPutScripts'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \OpenAPI\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasPutScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasPutScriptsRequest($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['schemasPutScripts'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasPutScripts'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasPutScripts'
            );
        }

        // verify the required parameter 'schema_scripts_dto' is set
        if ($schema_scripts_dto === null || (is_array($schema_scripts_dto) && count($schema_scripts_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema_scripts_dto when calling schemasPutScripts'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/scripts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($schema_scripts_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($schema_scripts_dto));
            } else {
                $httpBody = $schema_scripts_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation schemasUnpublishSchema
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasUnpublishSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto
     */
    public function schemasUnpublishSchema($app, $schema, string $contentType = self::contentTypes['schemasUnpublishSchema'][0])
    {
        list($response) = $this->schemasUnpublishSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation schemasUnpublishSchemaWithHttpInfo
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasUnpublishSchema'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SchemaDto|\OpenAPI\Client\Model\ErrorDto|\OpenAPI\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function schemasUnpublishSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasUnpublishSchema'][0])
    {
        $request = $this->schemasUnpublishSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\OpenAPI\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation schemasUnpublishSchemaAsync
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasUnpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasUnpublishSchemaAsync($app, $schema, string $contentType = self::contentTypes['schemasUnpublishSchema'][0])
    {
        return $this->schemasUnpublishSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation schemasUnpublishSchemaAsyncWithHttpInfo
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasUnpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function schemasUnpublishSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['schemasUnpublishSchema'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SchemaDto';
        $request = $this->schemasUnpublishSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'schemasUnpublishSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['schemasUnpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function schemasUnpublishSchemaRequest($app, $schema, string $contentType = self::contentTypes['schemasUnpublishSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling schemasUnpublishSchema'
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling schemasUnpublishSchema'
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/unpublish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}

<?php
/**
 * SchemasApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Squidex\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Squidex API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.8.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Squidex\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Squidex\Client\ApiException;
use Squidex\Client\Configuration;
use Squidex\Client\HeaderSelector;
use Squidex\Client\ObjectSerializer;

/**
 * SchemasApi Class Doc Comment
 *
 * @category Class
 * @package  Squidex\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SchemasApi
{
    /**
     * @var
     */
    protected $options;
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'deleteField' => [
            'application/json',
        ],
        'deleteNestedField' => [
            'application/json',
        ],
        'disableField' => [
            'application/json',
        ],
        'disableNestedField' => [
            'application/json',
        ],
        'enableField' => [
            'application/json',
        ],
        'enableNestedField' => [
            'application/json',
        ],
        'hideField' => [
            'application/json',
        ],
        'hideNestedField' => [
            'application/json',
        ],
        'lockField' => [
            'application/json',
        ],
        'lockNestedField' => [
            'application/json',
        ],
        'postField' => [
            'application/json',
        ],
        'postNestedField' => [
            'application/json',
        ],
        'putField' => [
            'application/json',
        ],
        'putNestedField' => [
            'application/json',
        ],
        'putNestedFieldOrdering' => [
            'application/json',
        ],
        'putSchemaFieldOrdering' => [
            'application/json',
        ],
        'putSchemaUIFields' => [
            'application/json',
        ],
        'showField' => [
            'application/json',
        ],
        'showNestedField' => [
            'application/json',
        ],
        'deleteSchema' => [
            'application/json',
        ],
        'getSchema' => [
            'application/json',
        ],
        'getSchemas' => [
            'application/json',
        ],
        'postSchema' => [
            'application/json',
        ],
        'publishSchema' => [
            'application/json',
        ],
        'putCategory' => [
            'application/json',
        ],
        'putPreviewUrls' => [
            'application/json',
        ],
        'putRules' => [
            'application/json',
        ],
        'putSchema' => [
            'application/json',
        ],
        'putSchemaSync' => [
            'application/json',
        ],
        'putScripts' => [
            'application/json',
        ],
        'unpublishSchema' => [
            'application/json',
        ],
    ];

/**
     * @param $options
     */
    public function __construct($config, $client) {
        $this->client =  $client;
        $this->config =  $config;
        $this->headerSelector = new HeaderSelector();
        $this->hostIndex = 0;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteField
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function deleteField($app, $schema, $id, string $contentType = self::contentTypes['deleteField'][0])
    {
        list($response) = $this->deleteFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation deleteFieldWithHttpInfo
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['deleteField'][0])
    {
        $request = $this->deleteFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteFieldAsync
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['deleteField'][0])
    {
        return $this->deleteFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteFieldAsyncWithHttpInfo
     *
     * Delete a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['deleteField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->deleteFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['deleteField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNestedField
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function deleteNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['deleteNestedField'][0])
    {
        list($response) = $this->deleteNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation deleteNestedFieldWithHttpInfo
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['deleteNestedField'][0])
    {
        $request = $this->deleteNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNestedFieldAsync
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['deleteNestedField'][0])
    {
        return $this->deleteNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNestedFieldAsyncWithHttpInfo
     *
     * Delete a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['deleteNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->deleteNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['deleteNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableField
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function disableField($app, $schema, $id, string $contentType = self::contentTypes['disableField'][0])
    {
        list($response) = $this->disableFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation disableFieldWithHttpInfo
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['disableField'][0])
    {
        $request = $this->disableFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation disableFieldAsync
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['disableField'][0])
    {
        return $this->disableFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableFieldAsyncWithHttpInfo
     *
     * Disable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['disableField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->disableFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['disableField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation disableNestedField
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function disableNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['disableNestedField'][0])
    {
        list($response) = $this->disableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation disableNestedFieldWithHttpInfo
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['disableNestedField'][0])
    {
        $request = $this->disableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation disableNestedFieldAsync
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['disableNestedField'][0])
    {
        return $this->disableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation disableNestedFieldAsyncWithHttpInfo
     *
     * Disable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function disableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['disableNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->disableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'disableNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to disable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['disableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function disableNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['disableNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/disable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableField
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function enableField($app, $schema, $id, string $contentType = self::contentTypes['enableField'][0])
    {
        list($response) = $this->enableFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation enableFieldWithHttpInfo
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['enableField'][0])
    {
        $request = $this->enableFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enableFieldAsync
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['enableField'][0])
    {
        return $this->enableFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableFieldAsyncWithHttpInfo
     *
     * Enable a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['enableField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->enableFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['enableField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation enableNestedField
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function enableNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['enableNestedField'][0])
    {
        list($response) = $this->enableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation enableNestedFieldWithHttpInfo
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['enableNestedField'][0])
    {
        $request = $this->enableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation enableNestedFieldAsync
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['enableNestedField'][0])
    {
        return $this->enableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation enableNestedFieldAsyncWithHttpInfo
     *
     * Enable a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function enableNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['enableNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->enableNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'enableNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to enable. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['enableNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function enableNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['enableNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/enable';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideField
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function hideField($app, $schema, $id, string $contentType = self::contentTypes['hideField'][0])
    {
        list($response) = $this->hideFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation hideFieldWithHttpInfo
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['hideField'][0])
    {
        $request = $this->hideFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation hideFieldAsync
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['hideField'][0])
    {
        return $this->hideFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideFieldAsyncWithHttpInfo
     *
     * Hide a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['hideField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->hideFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['hideField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation hideNestedField
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function hideNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['hideNestedField'][0])
    {
        list($response) = $this->hideNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation hideNestedFieldWithHttpInfo
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function hideNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['hideNestedField'][0])
    {
        $request = $this->hideNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation hideNestedFieldAsync
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['hideNestedField'][0])
    {
        return $this->hideNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation hideNestedFieldAsyncWithHttpInfo
     *
     * Hide a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function hideNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['hideNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->hideNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'hideNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to hide. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['hideNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function hideNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['hideNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/hide';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockField
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function lockField($app, $schema, $id, string $contentType = self::contentTypes['lockField'][0])
    {
        list($response) = $this->lockFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation lockFieldWithHttpInfo
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['lockField'][0])
    {
        $request = $this->lockFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lockFieldAsync
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['lockField'][0])
    {
        return $this->lockFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockFieldAsyncWithHttpInfo
     *
     * Lock a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['lockField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->lockFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['lockField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation lockNestedField
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function lockNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['lockNestedField'][0])
    {
        list($response) = $this->lockNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation lockNestedFieldWithHttpInfo
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function lockNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['lockNestedField'][0])
    {
        $request = $this->lockNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation lockNestedFieldAsync
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['lockNestedField'][0])
    {
        return $this->lockNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation lockNestedFieldAsyncWithHttpInfo
     *
     * Lock a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function lockNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['lockNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->lockNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'lockNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to lock. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['lockNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function lockNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['lockNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/lock';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postField
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function postField($app, $schema, $add_field_dto, string $contentType = self::contentTypes['postField'][0])
    {
        list($response) = $this->postFieldWithHttpInfo($app, $schema, $add_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation postFieldWithHttpInfo
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function postFieldWithHttpInfo($app, $schema, $add_field_dto, string $contentType = self::contentTypes['postField'][0])
    {
        $request = $this->postFieldRequest($app, $schema, $add_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postFieldAsync
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFieldAsync($app, $schema, $add_field_dto, string $contentType = self::contentTypes['postField'][0])
    {
        return $this->postFieldAsyncWithHttpInfo($app, $schema, $add_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postFieldAsyncWithHttpInfo
     *
     * Add a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postFieldAsyncWithHttpInfo($app, $schema, $add_field_dto, string $contentType = self::contentTypes['postField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->postFieldRequest($app, $schema, $add_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postFieldRequest($app, $schema, $add_field_dto, string $contentType = self::contentTypes['postField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'add_field_dto' is set
        if ($add_field_dto === null || (is_array($add_field_dto) && count($add_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_field_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_field_dto));
            } else {
                $httpBody = $add_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postNestedField
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function postNestedField($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['postNestedField'][0])
    {
        list($response) = $this->postNestedFieldWithHttpInfo($app, $schema, $parent_id, $add_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation postNestedFieldWithHttpInfo
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function postNestedFieldWithHttpInfo($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['postNestedField'][0])
    {
        $request = $this->postNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postNestedFieldAsync
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNestedFieldAsync($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['postNestedField'][0])
    {
        return $this->postNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $add_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postNestedFieldAsyncWithHttpInfo
     *
     * Add a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['postNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->postNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\AddFieldDto $add_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postNestedFieldRequest($app, $schema, $parent_id, $add_field_dto, string $contentType = self::contentTypes['postNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'add_field_dto' is set
        if ($add_field_dto === null || (is_array($add_field_dto) && count($add_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $add_field_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($add_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($add_field_dto));
            } else {
                $httpBody = $add_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putField
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putField($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['putField'][0])
    {
        list($response) = $this->putFieldWithHttpInfo($app, $schema, $id, $update_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation putFieldWithHttpInfo
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putFieldWithHttpInfo($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['putField'][0])
    {
        $request = $this->putFieldRequest($app, $schema, $id, $update_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putFieldAsync
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldAsync($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['putField'][0])
    {
        return $this->putFieldAsyncWithHttpInfo($app, $schema, $id, $update_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putFieldAsyncWithHttpInfo
     *
     * Update a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putFieldAsyncWithHttpInfo($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['putField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putFieldRequest($app, $schema, $id, $update_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putFieldRequest($app, $schema, $id, $update_field_dto, string $contentType = self::contentTypes['putField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }

        // verify the required parameter 'update_field_dto' is set
        if ($update_field_dto === null || (is_array($update_field_dto) && count($update_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_field_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_field_dto));
            } else {
                $httpBody = $update_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putNestedField
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putNestedField($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['putNestedField'][0])
    {
        list($response) = $this->putNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, $contentType);
        return $response;
    }

    /**
     * Operation putNestedFieldWithHttpInfo
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['putNestedField'][0])
    {
        $request = $this->putNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putNestedFieldAsync
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNestedFieldAsync($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['putNestedField'][0])
    {
        return $this->putNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putNestedFieldAsyncWithHttpInfo
     *
     * Update a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['putNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to update. (required)
     * @param  \Squidex\Client\Model\UpdateFieldDto $update_field_dto The field object that needs to be added to the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putNestedFieldRequest($app, $schema, $parent_id, $id, $update_field_dto, string $contentType = self::contentTypes['putNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }

        // verify the required parameter 'update_field_dto' is set
        if ($update_field_dto === null || (is_array($update_field_dto) && count($update_field_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_field_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_field_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_field_dto));
            } else {
                $httpBody = $update_field_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putNestedFieldOrdering
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putNestedFieldOrdering($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['putNestedFieldOrdering'][0])
    {
        list($response) = $this->putNestedFieldOrderingWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation putNestedFieldOrderingWithHttpInfo
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putNestedFieldOrderingWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['putNestedFieldOrdering'][0])
    {
        $request = $this->putNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putNestedFieldOrderingAsync
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNestedFieldOrderingAsync($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['putNestedFieldOrdering'][0])
    {
        return $this->putNestedFieldOrderingAsyncWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putNestedFieldOrderingAsyncWithHttpInfo
     *
     * Reorder all nested fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putNestedFieldOrderingAsyncWithHttpInfo($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['putNestedFieldOrdering'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putNestedFieldOrdering'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putNestedFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putNestedFieldOrderingRequest($app, $schema, $parent_id, $reorder_fields_dto, string $contentType = self::contentTypes['putNestedFieldOrdering'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'reorder_fields_dto' is set
        if ($reorder_fields_dto === null || (is_array($reorder_fields_dto) && count($reorder_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reorder_fields_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/ordering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reorder_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reorder_fields_dto));
            } else {
                $httpBody = $reorder_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSchemaFieldOrdering
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putSchemaFieldOrdering($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['putSchemaFieldOrdering'][0])
    {
        list($response) = $this->putSchemaFieldOrderingWithHttpInfo($app, $schema, $reorder_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation putSchemaFieldOrderingWithHttpInfo
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSchemaFieldOrderingWithHttpInfo($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['putSchemaFieldOrdering'][0])
    {
        $request = $this->putSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSchemaFieldOrderingAsync
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaFieldOrderingAsync($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['putSchemaFieldOrdering'][0])
    {
        return $this->putSchemaFieldOrderingAsyncWithHttpInfo($app, $schema, $reorder_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSchemaFieldOrderingAsyncWithHttpInfo
     *
     * Reorder all fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaFieldOrderingAsyncWithHttpInfo($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['putSchemaFieldOrdering'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSchemaFieldOrdering'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ReorderFieldsDto $reorder_fields_dto The request that contains the field ids. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaFieldOrdering'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSchemaFieldOrderingRequest($app, $schema, $reorder_fields_dto, string $contentType = self::contentTypes['putSchemaFieldOrdering'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'reorder_fields_dto' is set
        if ($reorder_fields_dto === null || (is_array($reorder_fields_dto) && count($reorder_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $reorder_fields_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/ordering';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($reorder_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($reorder_fields_dto));
            } else {
                $httpBody = $reorder_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSchemaUIFields
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putSchemaUIFields($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['putSchemaUIFields'][0])
    {
        list($response) = $this->putSchemaUIFieldsWithHttpInfo($app, $schema, $configure_ui_fields_dto, $contentType);
        return $response;
    }

    /**
     * Operation putSchemaUIFieldsWithHttpInfo
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSchemaUIFieldsWithHttpInfo($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['putSchemaUIFields'][0])
    {
        $request = $this->putSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSchemaUIFieldsAsync
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaUIFieldsAsync($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['putSchemaUIFields'][0])
    {
        return $this->putSchemaUIFieldsAsyncWithHttpInfo($app, $schema, $configure_ui_fields_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSchemaUIFieldsAsyncWithHttpInfo
     *
     * Configure UI fields.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaUIFieldsAsyncWithHttpInfo($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['putSchemaUIFields'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSchemaUIFields'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureUIFieldsDto $configure_ui_fields_dto The request that contains the field names. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaUIFields'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSchemaUIFieldsRequest($app, $schema, $configure_ui_fields_dto, string $contentType = self::contentTypes['putSchemaUIFields'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'configure_ui_fields_dto' is set
        if ($configure_ui_fields_dto === null || (is_array($configure_ui_fields_dto) && count($configure_ui_fields_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configure_ui_fields_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/ui';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($configure_ui_fields_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($configure_ui_fields_dto));
            } else {
                $httpBody = $configure_ui_fields_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showField
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function showField($app, $schema, $id, string $contentType = self::contentTypes['showField'][0])
    {
        list($response) = $this->showFieldWithHttpInfo($app, $schema, $id, $contentType);
        return $response;
    }

    /**
     * Operation showFieldWithHttpInfo
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function showFieldWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['showField'][0])
    {
        $request = $this->showFieldRequest($app, $schema, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showFieldAsync
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFieldAsync($app, $schema, $id, string $contentType = self::contentTypes['showField'][0])
    {
        return $this->showFieldAsyncWithHttpInfo($app, $schema, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showFieldAsyncWithHttpInfo
     *
     * Show a schema field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showFieldAsyncWithHttpInfo($app, $schema, $id, string $contentType = self::contentTypes['showField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->showFieldRequest($app, $schema, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function showFieldRequest($app, $schema, $id, string $contentType = self::contentTypes['showField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{id}/show';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation showNestedField
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function showNestedField($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['showNestedField'][0])
    {
        list($response) = $this->showNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation showNestedFieldWithHttpInfo
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showNestedField'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function showNestedFieldWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['showNestedField'][0])
    {
        $request = $this->showNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation showNestedFieldAsync
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showNestedFieldAsync($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['showNestedField'][0])
    {
        return $this->showNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation showNestedFieldAsyncWithHttpInfo
     *
     * Show a nested field.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function showNestedFieldAsyncWithHttpInfo($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['showNestedField'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->showNestedFieldRequest($app, $schema, $parent_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'showNestedField'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  int $parent_id The parent field id. (required)
     * @param  int $id The ID of the field to show. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['showNestedField'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function showNestedFieldRequest($app, $schema, $parent_id, $id, string $contentType = self::contentTypes['showNestedField'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'parent_id' is set
        if ($parent_id === null || (is_array($parent_id) && count($parent_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $parent_id when calling '
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/fields/{parentId}/nested/{id}/show';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }
        // path params
        if ($parent_id !== null) {
            $resourcePath = str_replace(
                '{' . 'parentId' . '}',
                ObjectSerializer::toPathValue($parent_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSchema
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteSchema($app, $schema, string $contentType = self::contentTypes['deleteSchema'][0])
    {
        $this->deleteSchemaWithHttpInfo($app, $schema, $contentType);
    }

    /**
     * Operation deleteSchemaWithHttpInfo
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['deleteSchema'][0])
    {
        $request = $this->deleteSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSchemaAsync
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSchemaAsync($app, $schema, string $contentType = self::contentTypes['deleteSchema'][0])
    {
        return $this->deleteSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSchemaAsyncWithHttpInfo
     *
     * Delete a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['deleteSchema'][0])
    {
        $returnType = '';
        $request = $this->deleteSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to delete. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['deleteSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function deleteSchemaRequest($app, $schema, string $contentType = self::contentTypes['deleteSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSchema
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto
     */
    public function getSchema($app, $schema, string $contentType = self::contentTypes['getSchema'][0])
    {
        list($response) = $this->getSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation getSchemaWithHttpInfo
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['getSchema'][0])
    {
        $request = $this->getSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSchemaAsync
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchemaAsync($app, $schema, string $contentType = self::contentTypes['getSchema'][0])
    {
        return $this->getSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSchemaAsyncWithHttpInfo
     *
     * Get a schema by name.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['getSchema'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->getSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSchemaRequest($app, $schema, string $contentType = self::contentTypes['getSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getSchemas
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchemas'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemasDto|\Squidex\Client\Model\ErrorDto
     */
    public function getSchemas($app, string $contentType = self::contentTypes['getSchemas'][0])
    {
        list($response) = $this->getSchemasWithHttpInfo($app, $contentType);
        return $response;
    }

    /**
     * Operation getSchemasWithHttpInfo
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchemas'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemasDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function getSchemasWithHttpInfo($app, string $contentType = self::contentTypes['getSchemas'][0])
    {
        $request = $this->getSchemasRequest($app, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemasDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemasDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemasDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemasDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemasDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getSchemasAsync
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchemasAsync($app, string $contentType = self::contentTypes['getSchemas'][0])
    {
        return $this->getSchemasAsyncWithHttpInfo($app, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getSchemasAsyncWithHttpInfo
     *
     * Get schemas.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getSchemasAsyncWithHttpInfo($app, string $contentType = self::contentTypes['getSchemas'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemasDto';
        $request = $this->getSchemasRequest($app, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getSchemas'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getSchemas'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getSchemasRequest($app, string $contentType = self::contentTypes['getSchemas'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation postSchema
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \Squidex\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function postSchema($app, $create_schema_dto, string $contentType = self::contentTypes['postSchema'][0])
    {
        list($response) = $this->postSchemaWithHttpInfo($app, $create_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation postSchemaWithHttpInfo
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \Squidex\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function postSchemaWithHttpInfo($app, $create_schema_dto, string $contentType = self::contentTypes['postSchema'][0])
    {
        $request = $this->postSchemaRequest($app, $create_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 409:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 409:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation postSchemaAsync
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \Squidex\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSchemaAsync($app, $create_schema_dto, string $contentType = self::contentTypes['postSchema'][0])
    {
        return $this->postSchemaAsyncWithHttpInfo($app, $create_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation postSchemaAsyncWithHttpInfo
     *
     * Create a new schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  \Squidex\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function postSchemaAsyncWithHttpInfo($app, $create_schema_dto, string $contentType = self::contentTypes['postSchema'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->postSchemaRequest($app, $create_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'postSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  \Squidex\Client\Model\CreateSchemaDto $create_schema_dto The schema object that needs to be added to the app. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['postSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function postSchemaRequest($app, $create_schema_dto, string $contentType = self::contentTypes['postSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'create_schema_dto' is set
        if ($create_schema_dto === null || (is_array($create_schema_dto) && count($create_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_schema_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($create_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($create_schema_dto));
            } else {
                $httpBody = $create_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation publishSchema
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function publishSchema($app, $schema, string $contentType = self::contentTypes['publishSchema'][0])
    {
        list($response) = $this->publishSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation publishSchemaWithHttpInfo
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function publishSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['publishSchema'][0])
    {
        $request = $this->publishSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation publishSchemaAsync
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishSchemaAsync($app, $schema, string $contentType = self::contentTypes['publishSchema'][0])
    {
        return $this->publishSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation publishSchemaAsyncWithHttpInfo
     *
     * Publish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function publishSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['publishSchema'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->publishSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'publishSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to publish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['publishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function publishSchemaRequest($app, $schema, string $contentType = self::contentTypes['publishSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/publish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putCategory
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putCategory'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putCategory($app, $schema, $change_category_dto, string $contentType = self::contentTypes['putCategory'][0])
    {
        list($response) = $this->putCategoryWithHttpInfo($app, $schema, $change_category_dto, $contentType);
        return $response;
    }

    /**
     * Operation putCategoryWithHttpInfo
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putCategory'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putCategoryWithHttpInfo($app, $schema, $change_category_dto, string $contentType = self::contentTypes['putCategory'][0])
    {
        $request = $this->putCategoryRequest($app, $schema, $change_category_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putCategoryAsync
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCategoryAsync($app, $schema, $change_category_dto, string $contentType = self::contentTypes['putCategory'][0])
    {
        return $this->putCategoryAsyncWithHttpInfo($app, $schema, $change_category_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putCategoryAsyncWithHttpInfo
     *
     * Update a schema category.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putCategoryAsyncWithHttpInfo($app, $schema, $change_category_dto, string $contentType = self::contentTypes['putCategory'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putCategoryRequest($app, $schema, $change_category_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putCategory'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ChangeCategoryDto $change_category_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putCategory'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putCategoryRequest($app, $schema, $change_category_dto, string $contentType = self::contentTypes['putCategory'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'change_category_dto' is set
        if ($change_category_dto === null || (is_array($change_category_dto) && count($change_category_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $change_category_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/category';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($change_category_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($change_category_dto));
            } else {
                $httpBody = $change_category_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putPreviewUrls
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewUrls'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putPreviewUrls($app, $schema, $request_body, string $contentType = self::contentTypes['putPreviewUrls'][0])
    {
        list($response) = $this->putPreviewUrlsWithHttpInfo($app, $schema, $request_body, $contentType);
        return $response;
    }

    /**
     * Operation putPreviewUrlsWithHttpInfo
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewUrls'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putPreviewUrlsWithHttpInfo($app, $schema, $request_body, string $contentType = self::contentTypes['putPreviewUrls'][0])
    {
        $request = $this->putPreviewUrlsRequest($app, $schema, $request_body, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putPreviewUrlsAsync
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewUrlsAsync($app, $schema, $request_body, string $contentType = self::contentTypes['putPreviewUrls'][0])
    {
        return $this->putPreviewUrlsAsyncWithHttpInfo($app, $schema, $request_body, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putPreviewUrlsAsyncWithHttpInfo
     *
     * Update the preview urls.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putPreviewUrlsAsyncWithHttpInfo($app, $schema, $request_body, string $contentType = self::contentTypes['putPreviewUrls'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putPreviewUrlsRequest($app, $schema, $request_body, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putPreviewUrls'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  array<string,string> $request_body The preview urls for the schema. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putPreviewUrls'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putPreviewUrlsRequest($app, $schema, $request_body, string $contentType = self::contentTypes['putPreviewUrls'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'request_body' is set
        if ($request_body === null || (is_array($request_body) && count($request_body) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $request_body when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/preview-urls';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($request_body)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($request_body));
            } else {
                $httpBody = $request_body;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putRules
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRules'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putRules($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['putRules'][0])
    {
        list($response) = $this->putRulesWithHttpInfo($app, $schema, $configure_field_rules_dto, $contentType);
        return $response;
    }

    /**
     * Operation putRulesWithHttpInfo
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRules'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putRulesWithHttpInfo($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['putRules'][0])
    {
        $request = $this->putRulesRequest($app, $schema, $configure_field_rules_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putRulesAsync
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRulesAsync($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['putRules'][0])
    {
        return $this->putRulesAsyncWithHttpInfo($app, $schema, $configure_field_rules_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putRulesAsyncWithHttpInfo
     *
     * Update the rules.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putRulesAsyncWithHttpInfo($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['putRules'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putRulesRequest($app, $schema, $configure_field_rules_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putRules'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\ConfigureFieldRulesDto $configure_field_rules_dto The schema rules object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putRules'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putRulesRequest($app, $schema, $configure_field_rules_dto, string $contentType = self::contentTypes['putRules'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'configure_field_rules_dto' is set
        if ($configure_field_rules_dto === null || (is_array($configure_field_rules_dto) && count($configure_field_rules_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $configure_field_rules_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($configure_field_rules_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($configure_field_rules_dto));
            } else {
                $httpBody = $configure_field_rules_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSchema
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putSchema($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['putSchema'][0])
    {
        list($response) = $this->putSchemaWithHttpInfo($app, $schema, $update_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation putSchemaWithHttpInfo
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSchemaWithHttpInfo($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['putSchema'][0])
    {
        $request = $this->putSchemaRequest($app, $schema, $update_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSchemaAsync
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaAsync($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['putSchema'][0])
    {
        return $this->putSchemaAsyncWithHttpInfo($app, $schema, $update_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSchemaAsyncWithHttpInfo
     *
     * Update a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaAsyncWithHttpInfo($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['putSchema'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putSchemaRequest($app, $schema, $update_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\UpdateSchemaDto $update_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSchemaRequest($app, $schema, $update_schema_dto, string $contentType = self::contentTypes['putSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'update_schema_dto' is set
        if ($update_schema_dto === null || (is_array($update_schema_dto) && count($update_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $update_schema_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($update_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($update_schema_dto));
            } else {
                $httpBody = $update_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putSchemaSync
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaSync'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putSchemaSync($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['putSchemaSync'][0])
    {
        list($response) = $this->putSchemaSyncWithHttpInfo($app, $schema, $synchronize_schema_dto, $contentType);
        return $response;
    }

    /**
     * Operation putSchemaSyncWithHttpInfo
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaSync'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putSchemaSyncWithHttpInfo($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['putSchemaSync'][0])
    {
        $request = $this->putSchemaSyncRequest($app, $schema, $synchronize_schema_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putSchemaSyncAsync
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaSyncAsync($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['putSchemaSync'][0])
    {
        return $this->putSchemaSyncAsyncWithHttpInfo($app, $schema, $synchronize_schema_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putSchemaSyncAsyncWithHttpInfo
     *
     * Synchronize a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putSchemaSyncAsyncWithHttpInfo($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['putSchemaSync'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putSchemaSyncRequest($app, $schema, $synchronize_schema_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putSchemaSync'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SynchronizeSchemaDto $synchronize_schema_dto The schema object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putSchemaSync'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putSchemaSyncRequest($app, $schema, $synchronize_schema_dto, string $contentType = self::contentTypes['putSchemaSync'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'synchronize_schema_dto' is set
        if ($synchronize_schema_dto === null || (is_array($synchronize_schema_dto) && count($synchronize_schema_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $synchronize_schema_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/sync';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($synchronize_schema_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($synchronize_schema_dto));
            } else {
                $httpBody = $synchronize_schema_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation putScripts
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putScripts'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function putScripts($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['putScripts'][0])
    {
        list($response) = $this->putScriptsWithHttpInfo($app, $schema, $schema_scripts_dto, $contentType);
        return $response;
    }

    /**
     * Operation putScriptsWithHttpInfo
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putScripts'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function putScriptsWithHttpInfo($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['putScripts'][0])
    {
        $request = $this->putScriptsRequest($app, $schema, $schema_scripts_dto, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation putScriptsAsync
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScriptsAsync($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['putScripts'][0])
    {
        return $this->putScriptsAsyncWithHttpInfo($app, $schema, $schema_scripts_dto, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation putScriptsAsyncWithHttpInfo
     *
     * Update the scripts.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function putScriptsAsyncWithHttpInfo($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['putScripts'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->putScriptsRequest($app, $schema, $schema_scripts_dto, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'putScripts'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema. (required)
     * @param  \Squidex\Client\Model\SchemaScriptsDto $schema_scripts_dto The schema scripts object that needs to updated. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['putScripts'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function putScriptsRequest($app, $schema, $schema_scripts_dto, string $contentType = self::contentTypes['putScripts'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }

        // verify the required parameter 'schema_scripts_dto' is set
        if ($schema_scripts_dto === null || (is_array($schema_scripts_dto) && count($schema_scripts_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema_scripts_dto when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/scripts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($schema_scripts_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($schema_scripts_dto));
            } else {
                $httpBody = $schema_scripts_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation unpublishSchema
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpublishSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto
     */
    public function unpublishSchema($app, $schema, string $contentType = self::contentTypes['unpublishSchema'][0])
    {
        list($response) = $this->unpublishSchemaWithHttpInfo($app, $schema, $contentType);
        return $response;
    }

    /**
     * Operation unpublishSchemaWithHttpInfo
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpublishSchema'] to see the possible values for this operation
     *
     * @throws \Squidex\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Squidex\Client\Model\SchemaDto|\Squidex\Client\Model\ErrorDto|\Squidex\Client\Model\ErrorDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function unpublishSchemaWithHttpInfo($app, $schema, string $contentType = self::contentTypes['unpublishSchema'][0])
    {
        $request = $this->unpublishSchemaRequest($app, $schema, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Squidex\Client\Model\SchemaDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\SchemaDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\SchemaDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Squidex\Client\Model\ErrorDto' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Squidex\Client\Model\ErrorDto' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Squidex\Client\Model\ErrorDto', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Squidex\Client\Model\SchemaDto';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\SchemaDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Squidex\Client\Model\ErrorDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation unpublishSchemaAsync
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unpublishSchemaAsync($app, $schema, string $contentType = self::contentTypes['unpublishSchema'][0])
    {
        return $this->unpublishSchemaAsyncWithHttpInfo($app, $schema, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation unpublishSchemaAsyncWithHttpInfo
     *
     * Unpublish a schema.
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function unpublishSchemaAsyncWithHttpInfo($app, $schema, string $contentType = self::contentTypes['unpublishSchema'][0])
    {
        $returnType = '\Squidex\Client\Model\SchemaDto';
        $request = $this->unpublishSchemaRequest($app, $schema, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'unpublishSchema'
     *
     * @param  string $app The name of the app. (required)
     * @param  string $schema The name of the schema to unpublish. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['unpublishSchema'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function unpublishSchemaRequest($app, $schema, string $contentType = self::contentTypes['unpublishSchema'][0])
    {

        // verify the required parameter 'app' is set
        if ($app === null || (is_array($app) && count($app) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $app when calling '
            );
        }

        // verify the required parameter 'schema' is set
        if ($schema === null || (is_array($schema) && count($schema) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $schema when calling '
            );
        }


        $resourcePath = '/api/apps/{app}/schemas/{schema}/unpublish';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($app !== null) {
            $resourcePath = str_replace(
                '{' . 'app' . '}',
                ObjectSerializer::toPathValue($app),
                $resourcePath
            );
        }
        // path params
        if ($schema !== null) {
            $resourcePath = str_replace(
                '{' . 'schema' . '}',
                ObjectSerializer::toPathValue($schema),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
